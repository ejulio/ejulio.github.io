<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Variable Byte Encoding on Júlio César Batista</title><link>https://juliocesarbatista.com/tags/variable-byte-encoding/</link><description>Recent content in Variable Byte Encoding on Júlio César Batista</description><generator>Hugo</generator><language>pt-br</language><lastBuildDate>Wed, 15 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://juliocesarbatista.com/tags/variable-byte-encoding/index.xml" rel="self" type="application/rss+xml"/><item><title>Compressão de índices: Variable Byte Encoding</title><link>https://juliocesarbatista.com/posts/compressao-indices-vbe/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/compressao-indices-vbe/</guid><description>&lt;p>Uma vez que o índice invertido está montado com &lt;em>postings lists&lt;/em>, é necessário persistí-lo em disco.
O detalhe é que, se o índice for persistido como texto em UTF-8, cada caractére vai requisitar ao menos 8 bytes.
Portando, o id &lt;code>4568912&lt;/code> requer 7 bytes para ser armazenado.
A contrapartida é que, se for armazenado como um numérico (&lt;code>int&lt;/code> por exemplo), precisa de apenas 4 bytes.
Porém, é possível conseguir uma melhora na compressão ao considerar a estrutura de dados que será armazenada.
Nesse caso, para cada &lt;em>termo&lt;/em>, uma lista de números é persistida.
Por exemplo, o termo &lt;em>t&lt;/em> tem a lista de ids &lt;code>[652389, 652390, 652399, 652659]&lt;/code>, requisitando &lt;code>4 * 4 * 8 = 128 bytes&lt;/code>.
Mas é possível ir além dado que a lista de ids é ordenada, assim é possível guardar apenas os &lt;em>gaps&lt;/em> (saltos) entre os ids.
Seguindo o exemplo anterior, a lista a ser persistida seria &lt;code>[652389, 1, 9, 260]&lt;/code> porque &lt;code>[652389, 652390 = 652389 + 1, 652399 = 652390 + 9, 652659 = 652399 + 260]&lt;/code>.
Mesmo assim, asinda é necessário guardar 4 inteiros totalizando 128 bytes.
Mas agora, obervando bem os valores, é possível perceber que apenas &lt;code>652389&lt;/code> e &lt;code>260&lt;/code> requerem um tipo &lt;code>int&lt;/code>, os valores &lt;code>1&lt;/code> e &lt;code>9&lt;/code> podem ser armazenados com apenas 1 byte cada um (1 byte pode armazenar valores de 0 à 255).
Assim, o espaço foi reduzido para &lt;code>2 * 4 * 8 + 2 * 8 = 80 bytes&lt;/code> (um pouco mais da metade do espaço necessário anteriormente).&lt;/p></description></item></channel></rss>