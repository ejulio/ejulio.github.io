<!doctype html><html lang=pt-br><head><title>Designing Data Intensive Applications - Chapter 1: Reliable, Scalable, and Maintainable Applications · Júlio César Batista
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Júlio César Batista"><meta name=description content="Um sistema de dados intensivos (data intensive applications) é definido por ter os dados como o principal desafio, seja a quantidade, complexidade, ou velocidade com que eles mudam.
As três características principais são: confiança (reliability), escalabilidade (_scalability) e Manutenibilidade (maintainability).
Confiança (Reliability) Link para o cabeçalho Basicamente, o sistema deve funcionar como o esperado. O desempenho é bom para a carga normal do sistema; mesmo que um usuário faça um erro, o sistema continua operando normalmente; apenas usuários autorizados podem usar a aplicação; assim por diante."><meta name=keywords content="blog,software,developer"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Designing Data Intensive Applications - Chapter 1: Reliable, Scalable, and Maintainable Applications"><meta name=twitter:description content="Um sistema de dados intensivos (data intensive applications) é definido por ter os dados como o principal desafio, seja a quantidade, complexidade, ou velocidade com que eles mudam.
As três características principais são: confiança (reliability), escalabilidade (_scalability) e Manutenibilidade (maintainability).
Confiança (Reliability) Link para o cabeçalho Basicamente, o sistema deve funcionar como o esperado. O desempenho é bom para a carga normal do sistema; mesmo que um usuário faça um erro, o sistema continua operando normalmente; apenas usuários autorizados podem usar a aplicação; assim por diante."><meta property="og:url" content="https://juliocesarbatista.com/posts/ddia-chapter-1/"><meta property="og:site_name" content="Júlio César Batista"><meta property="og:title" content="Designing Data Intensive Applications - Chapter 1: Reliable, Scalable, and Maintainable Applications"><meta property="og:description" content="Um sistema de dados intensivos (data intensive applications) é definido por ter os dados como o principal desafio, seja a quantidade, complexidade, ou velocidade com que eles mudam.
As três características principais são: confiança (reliability), escalabilidade (_scalability) e Manutenibilidade (maintainability).
Confiança (Reliability) Link para o cabeçalho Basicamente, o sistema deve funcionar como o esperado. O desempenho é bom para a carga normal do sistema; mesmo que um usuário faça um erro, o sistema continua operando normalmente; apenas usuários autorizados podem usar a aplicação; assim por diante."><meta property="og:locale" content="pt_br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-16T00:00:00+00:00"><meta property="article:tag" content="Livros"><meta property="article:tag" content="Designing Data Intensive Applications"><meta property="article:tag" content="Arquitetura De Software"><link rel=canonical href=https://juliocesarbatista.com/posts/ddia-chapter-1/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.07092c1350ffd254998dc43a44ae96e617d14af4df4602626878df89189c5e1a.css integrity="sha256-BwksE1D/0lSZjcQ6RK6W5hfRSvTfRgJiaHjfiRicXho=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://juliocesarbatista.com/>Júlio César Batista
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/publica%c3%a7%c3%a3o/>Publicações</a></li><li class=navigation-item><a class=navigation-link href=/tags/projeto/>Projetos</a></li><li class=navigation-item><a class=navigation-link href=/tags/notas/>Notas</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://juliocesarbatista.com/posts/ddia-chapter-1/>Designing Data Intensive Applications - Chapter 1: Reliable, Scalable, and Maintainable Applications</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2023-01-16T00:00:00Z>2023-01-16
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
9 minutos de leitura</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/livros/>Livros</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/designing-data-intensive-applications/>Designing Data Intensive Applications</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/arquitetura-de-software/>Arquitetura De Software</a></span></div></div></header><div class=post-content><p>Um sistema de dados intensivos (<em>data intensive applications</em>) é definido por ter os dados
como o principal desafio, seja a quantidade, complexidade, ou velocidade com que eles mudam.</p><p>As três características principais são: confiança (<em>reliability</em>),
escalabilidade (_scalability) e Manutenibilidade (<em>maintainability</em>).</p><h1 id=confiança-_reliability_>Confiança (<em>Reliability</em>)
<a class=heading-link href=#confian%c3%a7a-_reliability_><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h1><p>Basicamente, o sistema deve funcionar como o esperado.
O desempenho é bom para a carga normal do sistema;
mesmo que um usuário faça um erro, o sistema continua operando normalmente;
apenas usuários autorizados podem usar a aplicação;
assim por diante.</p><h2 id=_fault_-vs-_failure_><em>Fault</em> vs <em>Failure</em>
<a class=heading-link href=#_fault_-vs-_failure_><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><p>No inglês, pode-se utilizar <em>fault</em> e <em>failure</em> para indicar <em>falha</em> ou <em>erro</em>.
Entretanto, o significado muda um pouco.
Uma <em>fault</em> é quando um componente do sistema não está operando de forma adequada.
Uma <em>failure</em> é quando todo o sistema para de funcionar.
Também vale mencionar que é quase impossível reduzir a probabilidade de <em>faults</em> para zero.
Portanto, é importante desenvolver sistemas <em>fault-tolerant</em>, onde mesmo que um componente não esteja operando
como esperado, o sistema ainda consegue providenciar algum valor para o usuário.</p><h2 id=falhas-de-hardware>Falhas de hardware
<a class=heading-link href=#falhas-de-hardware><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><p>As <em>faults</em> que desenvolvedores menos percebem são as de hardware, especialmente quando o
software roda em nuvem (AWS, por exemplo).
Entretanto, é muito comum que o hardware falhe, principalmente em grandes <em>data centers</em> (cabo de rede desconectado, disco corrompido).
Mesmo assim, em alguns casos é possível corrigir o problema sem precisar desligar a máquina e, até mesmo, manter a aplicação rodando.
Porém, se houver um falha total da máquina, ou até mesmo se for o caso do cabo de rede desconectado, é necessário ter
uma alternativa para manter o sistema rodando quando uma máquina se torna indisponível.
Portanto, para lidar com falhas de hardware, é necessário pensar em sistemas multi-máquina, que podem rodar em várias máquinas ao mesmo tempo.</p><h2 id=falhas-de-software>Falhas de software
<a class=heading-link href=#falhas-de-software><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><p>Outro tipo de <em>fault</em> comum são as de software (também conhecidas como <em>bugs</em>).
Muitas vezes, elas ocorrem porque o sistema não foi desenvolvido para lidar com um tipo de cenário,
em outros casos, é porque algo não foi bem feito.
Assumindo que a implementação tenha sido feita corretamente, ainda podem ocorrer falhas se o ambiente mudar.
Por exemplo, um serviço que você consulta pode ficar indisponível (apesar que essa falha pode ser prevista).
O serviço pode mudar o conteúdo de retorno para algo desconhecido.
Pode existir uma condição no processo que faz ele reiniciar para determinadas entradas.
Enfim, existem várias formas que um software pode falhar.
Nesses casos, boas práticas são a melhor forma de mitigar esses problemas.
Boa análise das regras de negócio, testes unitários/integração, isolamento de processos e monitoramento (<em>observability</em>)
são alguns exemplos.</p><h2 id=falhas-humanas>Falhas humanas
<a class=heading-link href=#falhas-humanas><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><p>Quando um sistema está operando, é necessário dar manutenção (atualizar o banco de dados, por exemplo) e,
portanto, pessoas precisam intervir (em muitos casos).
Mesmo pessoas experientes podem cometer erros, pelos mais variados motivos.
Portanto, é necessário mitigar esses problemas de alguma forma.
A melhor forma para evitar esse tipo de problema seria não precisar de intervenção humana, portanto, minimizar
os pontos necessários já é uma forma de evitar problemas maiores.
Na mesma linha, automatizar os processos também ajuda, já que diminui a interação direta.
Em determinados casos, ter um ambiente de testes, isolado de produção é essencial para testar o que pode acontecer.
Permitir que o sistema volte para a versão anterior de forma fácil, ou recomputar dados que foram processados de forma errônea também ajuda.
Manter um checklist de operação, com passos explícitos que devem ser efetuados em determinadas condições.
Por fim, monitorar o ambiente de produção é essencial para garantir que o sistema está operando como esperado.</p><p>Em suma, um sistema deve se manter operante mesmo quando algo não ocorre como esperado.
A melhor analogia possível nesses cenários é a de um avião, que deve se manter operante mesmo em casos de falha.</p><h1 id=escalabilidade-_scalability_>Escalabilidade (<em>scalability</em>)
<a class=heading-link href=#escalabilidade-_scalability_><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h1><p>Escalabilidade é como o sistema lida com o aumento da <em>carga</em>.
Portanto, é preciso definir o que é <em>carga</em> para cada sistema.
Note que a <em>carga</em> pode mudar de sistema para sistema e isso afeta como o sistema é arquitetado para lidar com
esses cenários.
Portanto, a abordagem de um sistema para resolver determinado problema pode não ser a mesma para outros sistemas semelhantes.
Alguns exemplos para <em>carga</em> incluem: quantidade de requests por segundo, quantidade de usuários simultâneos, quantidade de
leitura/escrita no banco de dados, e muitas outras possibilidades.
Uma vez que entendemos os parâmetros de carga no sistema, podemos investigar o que acontece quando aumentamos
a carga e mantemos os recursos (CPU, memórioa, &mldr;); quanto precisamos aumentar os recursos para lidar com o
aumento de carga.</p><h2 id=latência-_latency_-tempo-de-resposta-_response-time_-e-vazão-_throughput_>Latência (<em>latency</em>), tempo de resposta (<em>response time</em>) e vazão (<em>throughput</em>)
<a class=heading-link href=#lat%c3%aancia-_latency_-tempo-de-resposta-_response-time_-e-vaz%c3%a3o-_throughput_><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><p><em>Throughput</em> é a melhor métrica para sistemas de processamento em pacotes (<em>batch</em>).
Normalmente, estamos interessados em quatos registros processamos por segundo, ou quanto tempo
leva para processar uma determinada quantidade de dados (GBs, por exemplo).
Para aplicações web, o <em>response time</em> passa a ser a melhor métrica, pois mede o tempo desde que o usuário
fez a requisição até receber a resposta.
Esse tempo inclui todo o tráfego de rede, espera em filas, serialização e tudo mais até que o usuário receba
de volta o que estava esperando.
Muitas vezes <em>lateency</em> e <em>response time</em> são usados como sinônimos, mas não representam a mesma coisa.
<em>Response time</em> é todo o tempo da requisição, enquanto latência é apenas o tempo que a requisição ficou esperando
em uma fila até ser processada.
Dessa forma, <em>latency</em> é uma parte do <em>response time</em>.
De forma geral, <em>latency</em> é sempre baixo, assumindo que não há uma quantidade exagerada de requisições chegando no
servidor, porque assim que a requisição chega, ela já é processada.
Quando a carga aumenta e o servidor passa a demorar para responder, provavelmente <em>latency</em> vai aumentar, visto que as
requisições passarão a ficar esperando na fila do servidor até serem processadas.</p><p>Vale notar que todas essas métricas não são números absolutos, mas mudam com o passar do tempo.
Portanto, sempre devemos falar delas como distribuições.
De forma geral, a média é sempre utilizada como uma medida para demonstrar o valor médio de uma distribuição.
Porém, nesses casos, usar percentis é melhor.
Por exemplo, o percentil 50 (também conhecida como a mediana), indica a medida observada por 50% dos usuários.
Supondo que a mediana do <em>response time</em> seja 1s, isso quer dizer que 50% das requisições são processadas em <code>&lt;= 1s</code>
e as demais em <code>> 1s</code>.
O objetivo é que o sistema sempre mantenha um bom <em>response time</em> em todos os casos, ou seja, <code>max(response time) &lt;= tempo desejado</code>.
Entretanto, quando passamos a otimizar além do percentil 99.9, a <em>latency</em>, normalmente, a <em>latency</em> passa a ser um grande componente do tempo total e torna a otimização mais difícil.
Portanto, a ideia é sempre definir a métrica aceitável e monitorar o desempenho do sistema para que a métrica se mantenha dentro dos padrões estabelecidos (por exemplo, 90% das requisições devem retornar em menos de 1s).</p><p>Em micro serviços, é comum medir o <em>response time</em> e <em>latency</em> para cada serviço de forma separada.
Mas também é importante medir o tempo total para o usuário receber a resposta.
Assumindo dois serviços, onde um deles retorna com 200ms e o outro leva 3s para responder, mesmo que
200ms e 3s estejam dentro do esperado, o usuário ainda teve que esperar ao menos 3s para obter a resposta.
Portanto, pode ser necessário ter que alterar a estrutura para que não exista esse gargalo onde um sistema
processou a requisição muito rápido, mas o outro levou 15x mais tempo.</p><h2 id=exemplo-do-twitter-em-2012>Exemplo do Twitter em 2012
<a class=heading-link href=#exemplo-do-twitter-em-2012><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><p>Em um primeiro momento, eles analisaram o sistema e perceberam que a média era de 4.6k requisições para <em>post tweet</em> e 300k requisições para ler a <em>timeline</em>.
Nesse cenário fica claro que o problema era obter os tweets que iriam ser carregados.
De forma geral, isso envolvia um <code>SELECT</code> com <code>JOIN</code> e <code>ORDER BY</code> que precisam ser recomputados toda vez nessas 300k requisições.
Assim, a solução deles foi mudar a arquitetura para criar uma <em>mailbox</em> para cada usuário e, quando um novo tweet é inserido, essas <em>mailboxes</em> são atualizadas.
Desa forma, carregar a <em>timeline</em> é apenas um <code>SELECT</code> nessa <em>mailbox</em> e maior parte da carga passa para o <em>post tweet</em>, o que faz sentido, dado a diferença na quantidade de requisições.
Essa <em>mailbox</em>, nada mais é que uma espécie de <em>cache</em> dos tweets, que é atualizada sempre que alguém adiciona um novo tweet.
Porém, ainda há o caso de pessoas muito famosas, que possuem milhões de seguidores e, nesses casos, inserir nas <em>mailboxes</em> passou a ser um problema.
Para resolver esse problema, eles tiveram que voltar para a versão anterior e manter uma versão híbrida.
Para pessoas com poucos seqguidores, atualiza a <em>mailbox</em> dos seguidores quando um novo tweet é inserido.
Para pessoas com muitos seguidores, junta a <em>mailbox</em> dos seguidores com os tweets dessa pessoa ao carregar a <em>timeline</em>.
É importante notar que isso só pode ser feito com boas métricas do sistema para entender ambos os casos de uso e como eles poderiam ser otimizados.</p><h1 id=manutenibilidade-_maintainability_>Manutenibilidade (<em>maintainability</em>)
<a class=heading-link href=#manutenibilidade-_maintainability_><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h1><p>É conhecido que o maior custo de um sistema está na manutenção e não no desenvolvimento.
Portanto, desenvolver sistemas que sejam simples de manter é crucial, especialmente
em sistemas de larga escala, onde vários componentes interagem.
Em princípio, um sistema deveria ser extensível visando futuras modificações e novos casos de uso.
Até certo ponto é possível fazer um paralelo com o <em>O</em> em <em>SOLID</em> para <em>Open-Closed Principle</em> onde
o componente deveria ser <em>aberto para extensão e fechado para modificação</em>.
Dessa forma, se o sistema possui uma API extensível, novos casos de uso podem ser criados em cima
do sistema base, sem necessidade de modificar o que está rodando.
Alguns exemplos incluem: SQL que fornece uma boa abstração para armazenar e buscar dados sem a necessidade de
mudar as regras do banco de dados para cada aplicação; GraphQL que expõe o back-end para que o front-end seja
responsável pelas consultas, assim não precisa alterar o back-end sempre que um novo caso de uso surge.</p><p>Outro fator crucial para a manutenção desses sistemas é a facilidade de entendê-los.
Deve ser relativamente simples para uma nova pessoa começar a desenvolver e contribuir em um sistema,
independente do seu tamanho.
Normalmente, documentação ajuda nesses casos.
Outro fator importante é cuidar das abstrações.
Enquanto as abstrações são importantes para estender o sistema no futuro com base numa camada comum,
um conjunto de abstrações ruins pode emaranhar os sistemas de forma que eles sejam fortemente acoplados,
onde mudanças em um sistema afetam os demais.
Além de ser muito difícil de manter um sistema nessas circunstâncias, também torna a operação do sistema muito
mais difícil.</p><p>Por fim, um sistema deve ser fácil de operar em produção.
Isso engloba a manutenção e a confiança do sistema.
Existem várias formas de atingir esse objetivo, algumas delas são:
documentação em dia, manter sistemas e máquinas atualizadas, manter uma espécie de lista de
acoplamentos entre sistemas, manter processos e boas práticas para <em>deploy</em> e como manter o ambiente de produção estável,
manter métricas e monitoramento dos sistemas em produção, evitar dependência de uma única máquina.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2024
Júlio César Batista
·
Promovido por <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-1BE56W9H8M"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1BE56W9H8M")}</script></body></html>