<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recuperação De Informação on Júlio César Batista</title><link>https://juliocesarbatista.com/tags/recupera%C3%A7%C3%A3o-de-informa%C3%A7%C3%A3o/</link><description>Recent content in Recuperação De Informação on Júlio César Batista</description><generator>Hugo</generator><language>pt-br</language><lastBuildDate>Sun, 12 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://juliocesarbatista.com/tags/recupera%C3%A7%C3%A3o-de-informa%C3%A7%C3%A3o/index.xml" rel="self" type="application/rss+xml"/><item><title>Índices invertidos e algoritmos de busca</title><link>https://juliocesarbatista.com/posts/indices-invertidos-e-algoritmos-de-busca/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/indices-invertidos-e-algoritmos-de-busca/</guid><description>&lt;p>&lt;a href="https://juliocesarbatista.com/palestras/indices-invertidos-e-algoritmos-de-busca.pdf" >Material da minha palestra sobre os fundamentos de mecanismos de busca no 5° encontro do Elastic Blumenau User Group.&lt;/a>&lt;/p></description></item><item><title>Correção ortográfica com índice k-gram</title><link>https://juliocesarbatista.com/posts/correcao-ortografica-k-gram-index/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/correcao-ortografica-k-gram-index/</guid><description>&lt;p>Ao escrever uma consulta, o usuário pode cometer erros ortográficos durante a digitação.
Esses erros podem ter duas formas: escrita incorreta da palavra (&lt;em>comesso&lt;/em> ao invés de &lt;em>começo&lt;/em>), contexto (&lt;em>no meu casa&lt;/em> ao invés de &lt;em>na minha casa&lt;/em>).
Note que no primeiro exemplo, a palavra está incorreta; no segundo, as palavras estão corretas mas o contexto é errado.
Nesse momento, a ideia é ver como é possível fazer a correção de erros de escrito (primeiro caso).
Uma forma de fazer isso é comparando partes menores das palavras (&lt;em>substrings&lt;/em>, ou &lt;em>k-grams&lt;/em>).
Um &lt;em>k-gram&lt;/em> define uma &lt;em>substring&lt;/em> de tamanho &lt;em>k&lt;/em>.
Portanto, os &lt;em>3-grams&lt;/em> de &lt;em>começo&lt;/em> são: &lt;code>com&lt;/code>, &lt;code>ome&lt;/code>, &lt;code>meç&lt;/code>, &lt;code>eço&lt;/code>.
Um detalhe importante é que, é comum adicionar $k - 1$ caractéres especiais, normalmente &lt;code>$&lt;/code> no início e fim da palavra.
Assim, os &lt;em>3-grams&lt;/em> de &lt;em>começo&lt;/em> são: &lt;code>$$c&lt;/code>, &lt;code>$co&lt;/code>, &lt;code>com&lt;/code>, &lt;code>ome&lt;/code>, &lt;code>meç&lt;/code>, &lt;code>eço&lt;/code>, &lt;code>ço$&lt;/code>, &lt;code>o$$&lt;/code>.
Uma vez que os &lt;em>3-grams&lt;/em> da palavra são conhecidos, é possível efetuar o mesmo procedimento para a palavras que será usada na comparação.
Nesse caso, &lt;em>comesso&lt;/em>: &lt;code>$$c&lt;/code>, &lt;code>$co&lt;/code>, &lt;code>com&lt;/code>, &lt;code>ome&lt;/code>, &lt;code>mes&lt;/code>, &lt;code>ess&lt;/code>, &lt;code>sso&lt;/code>, &lt;code>so$&lt;/code>, &lt;code>o$$&lt;/code>.&lt;/p></description></item><item><title>Executando consultas por frases: Positional Index</title><link>https://juliocesarbatista.com/posts/phrase-queries-positional-index/</link><pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/phrase-queries-positional-index/</guid><description>&lt;p>Para realizar a consulta por frases (sequências de palavras) é necessário um &lt;a href="https://juliocesarbatista.com/post/phrase-queries/" class="external-link" target="_blank" rel="noopener">índice &lt;em>k-gram&lt;/em>&lt;/a>.
Porém, criar um índice todas as combinações de termos pode ocupar muito espaço em disco/memória.
Principalmente se for necessário indexar combinações de 5 ou mais palavras, visto que muitas combinações podem aparecer apenas uma ou outra vez.
Uma solução para esse problema é um &lt;em>positional index&lt;/em> (índice de posições).&lt;/p>
&lt;p>Em um índice invertido, termos são mapeados para listas com &lt;em>ids&lt;/em> de documentos.
No &lt;em>positional index&lt;/em>, além dos &lt;em>ids&lt;/em>, também são mantidas as posições em que o termo aparece no documento.&lt;/p></description></item><item><title>Compressão de índices: Variable Byte Encoding</title><link>https://juliocesarbatista.com/posts/compressao-indices-vbe/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/compressao-indices-vbe/</guid><description>&lt;p>Uma vez que o índice invertido está montado com &lt;em>postings lists&lt;/em>, é necessário persistí-lo em disco.
O detalhe é que, se o índice for persistido como texto em UTF-8, cada caractére vai requisitar ao menos 8 bytes.
Portando, o id &lt;code>4568912&lt;/code> requer 7 bytes para ser armazenado.
A contrapartida é que, se for armazenado como um numérico (&lt;code>int&lt;/code> por exemplo), precisa de apenas 4 bytes.
Porém, é possível conseguir uma melhora na compressão ao considerar a estrutura de dados que será armazenada.
Nesse caso, para cada &lt;em>termo&lt;/em>, uma lista de números é persistida.
Por exemplo, o termo &lt;em>t&lt;/em> tem a lista de ids &lt;code>[652389, 652390, 652399, 652659]&lt;/code>, requisitando &lt;code>4 * 4 * 8 = 128 bytes&lt;/code>.
Mas é possível ir além dado que a lista de ids é ordenada, assim é possível guardar apenas os &lt;em>gaps&lt;/em> (saltos) entre os ids.
Seguindo o exemplo anterior, a lista a ser persistida seria &lt;code>[652389, 1, 9, 260]&lt;/code> porque &lt;code>[652389, 652390 = 652389 + 1, 652399 = 652390 + 9, 652659 = 652399 + 260]&lt;/code>.
Mesmo assim, asinda é necessário guardar 4 inteiros totalizando 128 bytes.
Mas agora, obervando bem os valores, é possível perceber que apenas &lt;code>652389&lt;/code> e &lt;code>260&lt;/code> requerem um tipo &lt;code>int&lt;/code>, os valores &lt;code>1&lt;/code> e &lt;code>9&lt;/code> podem ser armazenados com apenas 1 byte cada um (1 byte pode armazenar valores de 0 à 255).
Assim, o espaço foi reduzido para &lt;code>2 * 4 * 8 + 2 * 8 = 80 bytes&lt;/code> (um pouco mais da metade do espaço necessário anteriormente).&lt;/p></description></item><item><title>Executando consultas por frases</title><link>https://juliocesarbatista.com/posts/phrase-queries/</link><pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/phrase-queries/</guid><description>&lt;p>A partir de um &lt;a href="https://juliocesarbatista.com/post/indice-invertido/" class="external-link" target="_blank" rel="noopener">índice de termos/documentos&lt;/a> só é possível efetuar consultas de ocorrência de termos e filtros com operadores &lt;code>AND&lt;/code>, &lt;code>OR&lt;/code> e &lt;code>NOT&lt;/code>.
Entretanto, o que é preciso para executar uma consulta por &lt;em>presidente do Brasil&lt;/em>?
A forma mais simples, é converter essa consulta em &lt;code>presidente AND do AND Brasil&lt;/code> (o &lt;em>do&lt;/em> pode ser removido se quiser remover &lt;em>stop words&lt;/em>).
O detalhe é que essa consulta vai retornar qualquer documento que contenha &lt;em>presidente&lt;/em> e &lt;em>Brasil&lt;/em>, mas que não não fale necessariamento do &lt;em>presidente do Brasil&lt;/em>.
Um exemplo seria: &lt;em>O presidente do conselho está trabalhando para aumentar os empregos no Brasil&lt;/em>.
Esse documento é retornado pela consulta &lt;code>presidente AND do AND Brasil&lt;/code>, mas não tem nada a ver com &lt;em>presidente do Brasil&lt;/em>.
Portanto, é necessário melhorar a estrutura de índice para obter melhores resultados pelas consultas.&lt;/p></description></item><item><title>Algoritmos para consultar em índices</title><link>https://juliocesarbatista.com/posts/algoritmos-indices/</link><pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/algoritmos-indices/</guid><description>&lt;p>Uma das vantagens do &lt;a href="https://juliocesarbatista.com/post/indice-invertido/" class="external-link" target="_blank" rel="noopener">índice invertido&lt;/a> é a possibilidade de otimizar os algoritmos utilizados nas consultas.
Esses algoritmos já são implementados por &lt;code>set&lt;/code> no python, mas não garantem a sequência dos &lt;code>ids&lt;/code> dos documentos e também não permitem algumas otimizações.
Portanto, é necessário passar por esses algoritmos para ver as extensões e como elas podem ajudar.&lt;/p>
&lt;h2 id="intersecção-de-conjuntos">
 intersecção de conjuntos
 &lt;a class="heading-link" href="#intersec%c3%a7%c3%a3o-de-conjuntos">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabeçalho">&lt;/i>
 &lt;span class="sr-only">Link para o cabeçalho&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>Uma consulta &lt;code>casa AND blumenau&lt;/code> precisa efetuar a intersecção entre os documentos de &lt;code>casa&lt;/code> e os documentos de &lt;code>blumenau&lt;/code>.
O algoritmo de intersecção é uma solução para esse problema&lt;/p></description></item><item><title>Considerações sobre a construção de índices</title><link>https://juliocesarbatista.com/posts/consideracoes-sobre-indices/</link><pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/consideracoes-sobre-indices/</guid><description>&lt;p>Para construir um índice, seja uma &lt;a href="https://juliocesarbatista.com/post/matriz-incidencia-termo-documento/" class="external-link" target="_blank" rel="noopener">matriz de incidência&lt;/a> ou um &lt;a href="https://juliocesarbatista.com/post/indice-invertido/" class="external-link" target="_blank" rel="noopener">índice invertido&lt;/a>, alguns detalhes em relação aos &lt;em>documentos&lt;/em> e aos &lt;em>termos&lt;/em> do vocabulário devem ser considerados.&lt;/p>
&lt;h2 id="documentos">
 Documentos
 &lt;a class="heading-link" href="#documentos">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link para o cabeçalho">&lt;/i>
 &lt;span class="sr-only">Link para o cabeçalho&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>O primeiro ponto a se considerar é o que será indexado, o que será um &lt;em>documento&lt;/em> no índice.
Um livro pode ser considerado um &lt;em>documento&lt;/em>, o problema é que existem muitas palavras em um livro e diferentes palavras podem ocorrer em capítulos diferentes gerando um resultado não esperado.
Por exemplo, se o livro &lt;a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" class="external-link" target="_blank" rel="noopener">Introduction to Algorithms&lt;/a> for indexado, ele pode ser o resultado para a consulta &lt;code>graph AND quicksort&lt;/code>.
Não que o resultado esteja errado, essas palavras existem no livro, mas talvez o objetvo da consulta era encontrar uma forma de ordenar um grafo com &lt;em>quicksort&lt;/em>.
A solução é indexar partes menores do conteúdo, capítulos, páginas ou parágrafos.
Se levar esse concceito adiante, é possível indexar frases, porém o conteúdo será tão granular que muitas consultas podem falhar porque duas palavras não aparecem na mesma frase, mas no mesmo parágrafo.
Também é importante notar que a quantidade de documentos tem influência direta no tamanho do índice.
Portanto, será necessário um índice grande para armazenar muitos documento pequenos.&lt;/p></description></item><item><title>Índice invertido (inverted index)</title><link>https://juliocesarbatista.com/posts/indice-invertido/</link><pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/indice-invertido/</guid><description>&lt;p>&lt;a href="https://juliocesarbatista.com/post/matriz-incidencia-termo-documento/" class="external-link" target="_blank" rel="noopener">A matriz de incidência termo-documento&lt;/a> é uma das formas de representar um índice de termos por documento.
Mesmo usando o conceito de uma matriz esparsa, essa estrutura pode crescer muito para ser usada em memória.
Uma alternativa para esse caso é usar um índice invertido (&lt;em>inverted index&lt;/em>).&lt;/p>
&lt;p>Dados os seguintes documentos como exemplo:&lt;/p>
&lt;ul>
&lt;li>Uma casa à venda em Blumenau&lt;/li>
&lt;li>Vendo terreno em Gaspar&lt;/li>
&lt;li>Alugo apartamento em Indaial&lt;/li>
&lt;/ul>
&lt;p>A matriz de incidência é:&lt;/p></description></item><item><title>Matriz de incidência termo-documento</title><link>https://juliocesarbatista.com/posts/matriz-incidencia-termo-documento/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate><guid>https://juliocesarbatista.com/posts/matriz-incidencia-termo-documento/</guid><description>&lt;p>Para obter as ocorrências de uma &lt;em>query booleana&lt;/em>, por exemplo, &lt;code>casa AND blumenau&lt;/code> seria necessário passar em todos os documentos procurando por &lt;code>casa&lt;/code> e depois procurar novamente por &lt;code>blumenau&lt;/code>.
De certa forma, essa abordagem não é completamente ruim.
Mas existem algumas abordagens que podem melhorar o tempo da consulta e consumo de memória.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Agora considere uma nova consulta, por exemplo, &lt;code>casa AND gaspar&lt;/code>, seria necessário repassar em todos os documentos novamente.
Assim, existe um certo custo computacional que pode ser otimizado.
Uma forma de evitar esse problema é criando um índice (assim como no final de um livro, onde são listadas as palavras e as páginas que elas aparecem).
Nesse caso, a consulta pode ser simplificada procurando pelas palavras &lt;code>casa&lt;/code> e &lt;code>blumenau&lt;/code> e filtrar apenas os documentos onde ambas aparecem.
Note que a otimização foi em relação à não precisar passar em todas as palavras de todos os documentos.&lt;/p></description></item></channel></rss>