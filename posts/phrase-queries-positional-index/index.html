<!doctype html><html lang=pt-br><head><title>Executando consultas por frases: Positional Index · Júlio César Batista
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Júlio César Batista"><meta name=description content="Para realizar a consulta por frases (sequências de palavras) é necessário um índice k-gram.
Porém, criar um índice todas as combinações de termos pode ocupar muito espaço em disco/memória.
Principalmente se for necessário indexar combinações de 5 ou mais palavras, visto que muitas combinações podem aparecer apenas uma ou outra vez.
Uma solução para esse problema é um positional index (índice de posições).
Em um índice invertido, termos são mapeados para listas com ids de documentos.
No positional index, além dos ids, também são mantidas as posições em que o termo aparece no documento."><meta name=keywords content="blog,software,developer"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Executando consultas por frases: Positional Index"><meta name=twitter:description content="Para realizar a consulta por frases (sequências de palavras) é necessário um índice k-gram. Porém, criar um índice todas as combinações de termos pode ocupar muito espaço em disco/memória. Principalmente se for necessário indexar combinações de 5 ou mais palavras, visto que muitas combinações podem aparecer apenas uma ou outra vez. Uma solução para esse problema é um positional index (índice de posições).
Em um índice invertido, termos são mapeados para listas com ids de documentos. No positional index, além dos ids, também são mantidas as posições em que o termo aparece no documento."><meta property="og:url" content="https://juliocesarbatista.com/posts/phrase-queries-positional-index/"><meta property="og:site_name" content="Júlio César Batista"><meta property="og:title" content="Executando consultas por frases: Positional Index"><meta property="og:description" content="Para realizar a consulta por frases (sequências de palavras) é necessário um índice k-gram. Porém, criar um índice todas as combinações de termos pode ocupar muito espaço em disco/memória. Principalmente se for necessário indexar combinações de 5 ou mais palavras, visto que muitas combinações podem aparecer apenas uma ou outra vez. Uma solução para esse problema é um positional index (índice de posições).
Em um índice invertido, termos são mapeados para listas com ids de documentos. No positional index, além dos ids, também são mantidas as posições em que o termo aparece no documento."><meta property="og:locale" content="pt_br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-20T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-20T00:00:00+00:00"><meta property="article:tag" content="Recuperação De Informação"><meta property="article:tag" content="Python"><meta property="article:tag" content="Positional Index"><meta property="article:tag" content="Phrase Queries"><meta property="article:tag" content="Positional Intersect"><link rel=canonical href=https://juliocesarbatista.com/posts/phrase-queries-positional-index/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.07092c1350ffd254998dc43a44ae96e617d14af4df4602626878df89189c5e1a.css integrity="sha256-BwksE1D/0lSZjcQ6RK6W5hfRSvTfRgJiaHjfiRicXho=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://juliocesarbatista.com/>Júlio César Batista
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/publica%c3%a7%c3%a3o/>Publicações</a></li><li class=navigation-item><a class=navigation-link href=/tags/projeto/>Projetos</a></li><li class=navigation-item><a class=navigation-link href=/tags/notas/>Notas</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://juliocesarbatista.com/posts/phrase-queries-positional-index/>Executando consultas por frases: Positional Index</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-01-20T00:00:00Z>2020-01-20
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
7 minutos de leitura</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/recupera%C3%A7%C3%A3o-de-informa%C3%A7%C3%A3o/>Recuperação De Informação</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/python/>Python</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/positional-index/>Positional Index</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/phrase-queries/>Phrase Queries</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/positional-intersect/>Positional Intersect</a></span></div></div></header><div class=post-content><p>Para realizar a consulta por frases (sequências de palavras) é necessário um <a href=https://juliocesarbatista.com/post/phrase-queries/ class=external-link target=_blank rel=noopener>índice <em>k-gram</em></a>.
Porém, criar um índice todas as combinações de termos pode ocupar muito espaço em disco/memória.
Principalmente se for necessário indexar combinações de 5 ou mais palavras, visto que muitas combinações podem aparecer apenas uma ou outra vez.
Uma solução para esse problema é um <em>positional index</em> (índice de posições).</p><p>Em um índice invertido, termos são mapeados para listas com <em>ids</em> de documentos.
No <em>positional index</em>, além dos <em>ids</em>, também são mantidas as posições em que o termo aparece no documento.</p><p>Seguindo os documentos de exemplo:</p><ul><li>Uma casa à venda em Blumenau</li><li>Vendo terreno em Gaspar</li><li>Alugo apartamento em Indaial</li></ul><p>O <em>positional index</em> seria</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>positional_index = {
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;Uma&#34;</span>: {
</span></span><span style=display:flex><span>        0: [0]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;casa&#34;</span>: {
</span></span><span style=display:flex><span>        0: [1]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;à&#34;</span>: {
</span></span><span style=display:flex><span>        0: [2]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;venda&#34;</span>: {
</span></span><span style=display:flex><span>        0: [3]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;em&#34;</span>: {
</span></span><span style=display:flex><span>        0: [4],
</span></span><span style=display:flex><span>        1: [2],
</span></span><span style=display:flex><span>        2: [2]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;Blumenau&#34;</span>: {
</span></span><span style=display:flex><span>        0: [5]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;Vendo&#34;</span>: {
</span></span><span style=display:flex><span>        1: [0]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;terreno&#34;</span>: {
</span></span><span style=display:flex><span>        1: [1]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;Gaspar&#34;</span>: {
</span></span><span style=display:flex><span>        1: [3]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;Alugo&#34;</span>: {
</span></span><span style=display:flex><span>        2: [0]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;apartamento&#34;</span>: {
</span></span><span style=display:flex><span>        2: [1]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;Indaial&#34;</span>: {
</span></span><span style=display:flex><span>        2: [3]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A partir desse índice, é possível reconstruir os documentos, visto que existe a identificação dos documentos e posição em que cada termo aparece nos documentos.
Porém, a grande vantagem é que consultas por sequências de palavras podem ser executadas para qualquer quantidade.
Por exemplo, a consulta <code>casa em blumenau</code> pode ser executada, já que é possível encontrar os documentos e verificar se os termos <code>casa</code>, <code>em</code>, <code>blumenau</code> aparecem em sequência nesses documentos.
Também é possível executar consultas em intervalos/janelas (<em>windows</em>), como <code>casa \3 blumenau</code> (<em>proximity query</em>) indicando que se deseja todos os documentos onde <code>blumenau</code> aparece em até três termos de distância de <code>casa</code>.
Para executar essas consultas, é necessário implementar o algoritmo de <code>positional_intersect</code>, como demonstrado na <a href=https://nlp.stanford.edu/IR-book/html/htmledition/positional-indexes-1.html class=external-link target=_blank rel=noopener>seção Positional Indexes de <em>Introduction to Information Retrieval</em></a>.</p><p>Para construir o <em>positional index</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>nltk</span>
</span></span><span style=display:flex><span><span style=font-weight:700>from</span> <span style=font-weight:700>nltk.corpus</span> <span style=font-weight:700>import</span> brown
</span></span><span style=display:flex><span><span style=font-weight:700>from</span> <span style=font-weight:700>itertools</span> <span style=font-weight:700>import</span> chain
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>string</span>
</span></span><span style=display:flex><span><span style=font-weight:700>from</span> <span style=font-weight:700>collections</span> <span style=font-weight:700>import</span> defaultdict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nltk.download(<span style=font-style:italic>&#39;brown&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> filtrar_pontuacao(doc):
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> (p <span style=font-weight:700>for</span> p <span style=font-weight:700>in</span> doc <span style=font-weight:700>if</span> p <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> string.punctuation)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DOCUMENTOS = brown.paras()
</span></span><span style=display:flex><span>DOCUMENTOS = [list(chain.from_iterable(p)) <span style=font-weight:700>for</span> p <span style=font-weight:700>in</span> DOCUMENTOS]
</span></span><span style=display:flex><span>documentos = (filtrar_pontuacao(p) <span style=font-weight:700>for</span> p <span style=font-weight:700>in</span> DOCUMENTOS)
</span></span><span style=display:flex><span>documentos = [list(p) <span style=font-weight:700>for</span> p <span style=font-weight:700>in</span> documentos]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>positional_index = defaultdict(<span style=font-weight:700>lambda</span>: defaultdict(list))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>for</span> (doc_id, doc) <span style=font-weight:700>in</span> enumerate(documentos):
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> (i, termo) <span style=font-weight:700>in</span> enumerate(doc):
</span></span><span style=display:flex><span>        positional_index[termo][doc_id].append(i)
</span></span></code></pre></div><p>O algoritmo <code>positional_intersect</code> é similar a intersecção de listas, a diferença é que ele também verifica se a posição dos termos está em até uma distância <code>k</code>.
Na implementação abaixo, a grande diferença fica no bloco <code>else</code> que percorre as posições que os termos ocorrem e verifica se a posição do <em>termo 1</em> está até <code>k</code> distância da posição do <em>termo 2</em> (<code>abs(pp1_pos - pp2_pos) &lt;= k</code>).
O resultado é uma lista de tuplas contendo o <em>id</em> do documento e posição dos <em>termo 1</em> e <em>termo 2</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>def</span> positional_intersect(p1, p2, k):
</span></span><span style=display:flex><span>    answer = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    p1 = iter(p1.items())
</span></span><span style=display:flex><span>    p2 = iter(p2.items())
</span></span><span style=display:flex><span>    (p1_doc_id, pp1) = next(p1, (<span style=font-weight:700>None</span>, <span style=font-weight:700>None</span>))
</span></span><span style=display:flex><span>    (p2_doc_id, pp2) = next(p2, (<span style=font-weight:700>None</span>, <span style=font-weight:700>None</span>))
</span></span><span style=display:flex><span>    <span style=font-weight:700>while</span> <span style=font-weight:700>True</span>:
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> (p1_doc_id <span style=font-weight:700>and</span> p2_doc_id):
</span></span><span style=display:flex><span>            <span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> p1_doc_id &lt; p2_doc_id:
</span></span><span style=display:flex><span>            (p1_doc_id, pp1) = next(p1, (<span style=font-weight:700>None</span>, <span style=font-weight:700>None</span>))
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> p1_doc_id &gt; p2_doc_id:
</span></span><span style=display:flex><span>            (p2_doc_id, pp2) = next(p2, (<span style=font-weight:700>None</span>, <span style=font-weight:700>None</span>))
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> pp1_pos <span style=font-weight:700>in</span> pp1:
</span></span><span style=display:flex><span>                l = []
</span></span><span style=display:flex><span>                <span style=font-weight:700>for</span> pp2_pos <span style=font-weight:700>in</span> pp2:
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> abs(pp1_pos - pp2_pos) &lt;= k:
</span></span><span style=display:flex><span>                        answer.append((p1_doc_id, pp1_pos, pp2_pos))
</span></span><span style=display:flex><span>                    <span style=font-weight:700>elif</span> pp2_pos &gt; pp1_pos:
</span></span><span style=display:flex><span>                        <span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>            (p1_doc_id, pp1) = next(p1, (<span style=font-weight:700>None</span>, <span style=font-weight:700>None</span>))
</span></span><span style=display:flex><span>            (p2_doc_id, pp2) = next(p2, (<span style=font-weight:700>None</span>, <span style=font-weight:700>None</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> answer
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1 = {1: [1, 10, 100]}
</span></span><span style=display:flex><span>p2 = {2: [2, 11, 101]}
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 0) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 1) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 2) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 3) == []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1 = {1: [1, 10, 100]}
</span></span><span style=display:flex><span>p2 = {1: [2, 11, 101]}
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 0) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 1) == [(1, 1, 2), (1, 10, 11), (1, 100, 101)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 2) == [(1, 1, 2), (1, 10, 11), (1, 100, 101)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 3) == [(1, 1, 2), (1, 10, 11), (1, 100, 101)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1 = {1: [1, 10, 100, 200]}
</span></span><span style=display:flex><span>p2 = {1: [2, 13, 102, 204]}
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 0) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 1) == [(1, 1, 2)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 2) == [(1, 1, 2), (1, 100, 102)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 3) == [(1, 1, 2), (1, 10, 13), (1, 100, 102)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1 = {1: [1]}
</span></span><span style=display:flex><span>p2 = {1: [2, 13, 102, 204]}
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 0) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 1) == [(1, 1, 2)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 2) == [(1, 1, 2)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 3) == [(1, 1, 2)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1 = {1: [1]}
</span></span><span style=display:flex><span>p2 = {1: [2, 3]}
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 0) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 1) == [(1, 1, 2)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 2) == [(1, 1, 2), (1, 1, 3)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 3) == [(1, 1, 2), (1, 1, 3)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1 = {1: [2, 3]}
</span></span><span style=display:flex><span>p2 = {1: [1]}
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 0) == []
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 1) == [(1, 2, 1)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 2) == [(1, 2, 1), (1, 3, 1)]
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> positional_intersect(p1, p2, 3) == [(1, 2, 1), (1, 3, 1)]
</span></span></code></pre></div><p>Vale notar que o algoritmo considera a distância <code>k</code> em ambas as direções, portanto, <em>termo 2</em> pode aparecer até <code>k</code> termos antes ou depois de <em>termo 1</em>.
Abaixo segue o mesmo exemplo da consulta de índices <em>k-gram</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=font-style:italic>&#39;House /2 Representatives&#39;</span>)
</span></span><span style=display:flex><span>house = positional_index[<span style=font-style:italic>&#39;House&#39;</span>]
</span></span><span style=display:flex><span>representatives = positional_index[<span style=font-style:italic>&#39;Representatives&#39;</span>]
</span></span><span style=display:flex><span><span style=font-weight:700>for</span> (doc_id, p1, p2) <span style=font-weight:700>in</span> positional_intersect(house, representatives, 2):
</span></span><span style=display:flex><span>    print(
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;&gt;&#39;</span>,
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;[&#39;</span>,
</span></span><span style=display:flex><span>        doc_id,
</span></span><span style=display:flex><span>        p1,
</span></span><span style=display:flex><span>        p2,
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;]&#39;</span>,
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39; &#39;</span>.join(documentos[doc_id][p1 - 3:p2 + 3])
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    print(<span style=font-style:italic>&#39; &#39;</span>.join(DOCUMENTOS[doc_id]))
</span></span><span style=display:flex><span>    print()
</span></span></code></pre></div><p>Sendo o resultado (omitindo os textos para economizar espaço):</p><blockquote><p>House /2 Representatives</p></blockquote><blockquote><p>[ 102 15 17 ] by the Texas House of Representatives was an</p></blockquote><blockquote><p>[ 1889 61 63 ] representative with the House of Representatives turned guest</p></blockquote><blockquote><p>[ 7792 83 85 ] pushed through the House of Representatives by the</p></blockquote><blockquote><p>[ 8008 9 11 ] terms in the House of Representatives has been</p></blockquote><blockquote><p>[ 8010 28 30 ] Speaker of the House of Representatives more than</p></blockquote><blockquote><p>[ 8015 45 47 ] Member of the House of Representatives in the</p></blockquote><blockquote><p>[ 8189 7 9 ] the Senate and House of Representatives of the</p></blockquote><blockquote><p>[ 8199 7 9 ] the Senate and House of Representatives of the</p></blockquote><blockquote><p>[ 8202 7 9 ] the Senate and House of Representatives of the</p></blockquote><blockquote><p>[ 8525 65 67 ] Senate and the House of Representatives As I</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=font-style:italic>&#39;Texas House /2 Representatives&#39;</span>)
</span></span><span style=display:flex><span>texas = positional_index[<span style=font-style:italic>&#39;Texas&#39;</span>]
</span></span><span style=display:flex><span>house = positional_index[<span style=font-style:italic>&#39;House&#39;</span>]
</span></span><span style=display:flex><span>texas_house = defaultdict(list)
</span></span><span style=display:flex><span><span style=font-weight:700>for</span> (doc_id, _, i) <span style=font-weight:700>in</span> positional_intersect(texas, house, 1):
</span></span><span style=display:flex><span>    <span style=font-style:italic># ignora a posição de &#34;Texas&#34;, visto que &#34;House&#34;</span>
</span></span><span style=display:flex><span>    <span style=font-style:italic># será usado na próxima comparação</span>
</span></span><span style=display:flex><span>    texas_house[doc_id].append(i)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>representatives = positional_index[<span style=font-style:italic>&#39;Representatives&#39;</span>]
</span></span><span style=display:flex><span><span style=font-weight:700>for</span> (doc_id, p1, p2) <span style=font-weight:700>in</span> positional_intersect(texas_house, representatives, 2):
</span></span><span style=display:flex><span>    print(
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;&gt;&#39;</span>,
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;[&#39;</span>,
</span></span><span style=display:flex><span>        doc_id,
</span></span><span style=display:flex><span>        p1,
</span></span><span style=display:flex><span>        p2,
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;]&#39;</span>,
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39; &#39;</span>.join(documentos[doc_id][p1 - 3:p2 + 3])
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    print(<span style=font-style:italic>&#39; &#39;</span>.join(DOCUMENTOS[doc_id]))
</span></span><span style=display:flex><span>    print()
</span></span></code></pre></div><p>Sendo o resultado</p><blockquote><p>Texas House /2 Representatives</p></blockquote><blockquote><p>[ 102 15 17 ] by the Texas House of Representatives was an
Rep. James Cotten of Weatherford insisted that a water development bill passed by the Texas House of Representatives was an effort by big cities like Dallas and Fort Worth to cover up places like Paradise , a Wise County hamlet of 250 people .</p></blockquote><p>Vale notar que o <em>positional index</em> resolve a possibilidade de consultas com sequências indeterminadas de palavras.
Porém, elevando o custo computacional (requer executar mais interseções) e com um leve aumento de armazenamento (armazenar posições dos termos).
Mesmo assim, ainda pode ser melhor que usar índices <em>k-gram</em>.
Sendo que a melhor abordagem pode ser uma combinação híbrida dos dois índices.
Por exemplo, combinações muito frequentes de palavras, como <em>machine learning</em>, <em>Elvis Presley</em> poderiam ser pré-computadas e armazenadas num índice <em>k-gram</em> para evitar o uso do <em>positional index</em>, já que são consultas/frases frequentes.
Outro detalhe é a combinação de <em>stop words</em>, por exemplo <em>of the</em> ou <em>The Who</em> (banda), já que tendem a ser listas grandes e executar a intersecção pode ser muito custoso em cada execução.
Portanto, o melhor índice vai depender do caso de uso, mas uma solução conjunta pode ser a melhor solução após a análise de frequência de consultas.</p><h2 id=referências>Referências
<a class=heading-link href=#refer%c3%aancias><i class="fa-solid fa-link" aria-hidden=true title="Link para o cabeçalho"></i>
<span class=sr-only>Link para o cabeçalho</span></a></h2><ul><li><a href=https://nlp.stanford.edu/IR-book/html/htmledition/positional-indexes-1.html class=external-link target=_blank rel=noopener>Positional Indexes</a></li><li><a href=https://www.systems.ethz.ch/sites/default/files/file/ir2018spring/04%20Information%20Retrieval%20-%20Tolerant%20retrieval.pdf class=external-link target=_blank rel=noopener>Tolerant Retrieval</a></li><li><a href=http://web.stanford.edu/class/cs276/19handouts/lecture2-intro-boolean-1per.pdf class=external-link target=_blank rel=noopener>Inverted Indices: Dictionary and postings lists, boolean querying</a></li></ul></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2016 -
2024
Júlio César Batista
·
Promovido por <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-1BE56W9H8M"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1BE56W9H8M")}</script></body></html>