<!doctype html><html lang=pt-br><head><title>Compressão de índices: Variable Byte Encoding · Júlio César Batista
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Júlio César Batista"><meta name=description content="Uma vez que o índice invertido está montado com postings lists, é necessário persistí-lo em disco.
O detalhe é que, se o índice for persistido como texto em UTF-8, cada caractére vai requisitar ao menos 8 bytes.
Portando, o id 4568912 requer 7 bytes para ser armazenado.
A contrapartida é que, se for armazenado como um numérico (int por exemplo), precisa de apenas 4 bytes.
Porém, é possível conseguir uma melhora na compressão ao considerar a estrutura de dados que será armazenada.
Nesse caso, para cada termo, uma lista de números é persistida.
Por exemplo, o termo t tem a lista de ids [652389, 652390, 652399, 652659], requisitando 4 * 4 * 8 = 128 bytes.
Mas é possível ir além dado que a lista de ids é ordenada, assim é possível guardar apenas os gaps (saltos) entre os ids.
Seguindo o exemplo anterior, a lista a ser persistida seria [652389, 1, 9, 260] porque [652389, 652390 = 652389 + 1, 652399 = 652390 + 9, 652659 = 652399 + 260].
Mesmo assim, asinda é necessário guardar 4 inteiros totalizando 128 bytes.
Mas agora, obervando bem os valores, é possível perceber que apenas 652389 e 260 requerem um tipo int, os valores 1 e 9 podem ser armazenados com apenas 1 byte cada um (1 byte pode armazenar valores de 0 à 255).
Assim, o espaço foi reduzido para 2 * 4 * 8 + 2 * 8 = 80 bytes (um pouco mais da metade do espaço necessário anteriormente)."><meta name=keywords content="blog,software,developer"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="Compressão de índices: Variable Byte Encoding"><meta name=twitter:description content="Uma vez que o índice invertido está montado com postings lists, é necessário persistí-lo em disco. O detalhe é que, se o índice for persistido como texto em UTF-8, cada caractére vai requisitar ao menos 8 bytes. Portando, o id 4568912 requer 7 bytes para ser armazenado. A contrapartida é que, se for armazenado como um numérico (int por exemplo), precisa de apenas 4 bytes. Porém, é possível conseguir uma melhora na compressão ao considerar a estrutura de dados que será armazenada. Nesse caso, para cada termo, uma lista de números é persistida. Por exemplo, o termo t tem a lista de ids [652389, 652390, 652399, 652659], requisitando 4 * 4 * 8 = 128 bytes. Mas é possível ir além dado que a lista de ids é ordenada, assim é possível guardar apenas os gaps (saltos) entre os ids. Seguindo o exemplo anterior, a lista a ser persistida seria [652389, 1, 9, 260] porque [652389, 652390 = 652389 + 1, 652399 = 652390 + 9, 652659 = 652399 + 260]. Mesmo assim, asinda é necessário guardar 4 inteiros totalizando 128 bytes. Mas agora, obervando bem os valores, é possível perceber que apenas 652389 e 260 requerem um tipo int, os valores 1 e 9 podem ser armazenados com apenas 1 byte cada um (1 byte pode armazenar valores de 0 à 255). Assim, o espaço foi reduzido para 2 * 4 * 8 + 2 * 8 = 80 bytes (um pouco mais da metade do espaço necessário anteriormente)."><meta property="og:url" content="https://juliocesarbatista.com/posts/compressao-indices-vbe/"><meta property="og:site_name" content="Júlio César Batista"><meta property="og:title" content="Compressão de índices: Variable Byte Encoding"><meta property="og:description" content="Uma vez que o índice invertido está montado com postings lists, é necessário persistí-lo em disco. O detalhe é que, se o índice for persistido como texto em UTF-8, cada caractére vai requisitar ao menos 8 bytes. Portando, o id 4568912 requer 7 bytes para ser armazenado. A contrapartida é que, se for armazenado como um numérico (int por exemplo), precisa de apenas 4 bytes. Porém, é possível conseguir uma melhora na compressão ao considerar a estrutura de dados que será armazenada. Nesse caso, para cada termo, uma lista de números é persistida. Por exemplo, o termo t tem a lista de ids [652389, 652390, 652399, 652659], requisitando 4 * 4 * 8 = 128 bytes. Mas é possível ir além dado que a lista de ids é ordenada, assim é possível guardar apenas os gaps (saltos) entre os ids. Seguindo o exemplo anterior, a lista a ser persistida seria [652389, 1, 9, 260] porque [652389, 652390 = 652389 + 1, 652399 = 652390 + 9, 652659 = 652399 + 260]. Mesmo assim, asinda é necessário guardar 4 inteiros totalizando 128 bytes. Mas agora, obervando bem os valores, é possível perceber que apenas 652389 e 260 requerem um tipo int, os valores 1 e 9 podem ser armazenados com apenas 1 byte cada um (1 byte pode armazenar valores de 0 à 255). Assim, o espaço foi reduzido para 2 * 4 * 8 + 2 * 8 = 80 bytes (um pouco mais da metade do espaço necessário anteriormente)."><meta property="og:locale" content="pt_br"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-15T00:00:00+00:00"><meta property="article:tag" content="Recuperação De Informação"><meta property="article:tag" content="Variable Byte Encoding"><meta property="article:tag" content="Python"><meta property="article:tag" content="Índice Invertido"><link rel=canonical href=https://juliocesarbatista.com/posts/compressao-indices-vbe/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.07092c1350ffd254998dc43a44ae96e617d14af4df4602626878df89189c5e1a.css integrity="sha256-BwksE1D/0lSZjcQ6RK6W5hfRSvTfRgJiaHjfiRicXho=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://juliocesarbatista.com/>Júlio César Batista
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/publica%c3%a7%c3%a3o/>Publicações</a></li><li class=navigation-item><a class=navigation-link href=/tags/projeto/>Projetos</a></li><li class=navigation-item><a class=navigation-link href=/tags/notas/>Notas</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://juliocesarbatista.com/posts/compressao-indices-vbe/>Compressão de índices: Variable Byte Encoding</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-01-15T00:00:00Z>2020-01-15
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
4 minutos de leitura</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/recupera%C3%A7%C3%A3o-de-informa%C3%A7%C3%A3o/>Recuperação De Informação</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/variable-byte-encoding/>Variable Byte Encoding</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/python/>Python</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/%C3%ADndice-invertido/>Índice Invertido</a></span></div></div></header><div class=post-content><p>Uma vez que o índice invertido está montado com <em>postings lists</em>, é necessário persistí-lo em disco.
O detalhe é que, se o índice for persistido como texto em UTF-8, cada caractére vai requisitar ao menos 8 bytes.
Portando, o id <code>4568912</code> requer 7 bytes para ser armazenado.
A contrapartida é que, se for armazenado como um numérico (<code>int</code> por exemplo), precisa de apenas 4 bytes.
Porém, é possível conseguir uma melhora na compressão ao considerar a estrutura de dados que será armazenada.
Nesse caso, para cada <em>termo</em>, uma lista de números é persistida.
Por exemplo, o termo <em>t</em> tem a lista de ids <code>[652389, 652390, 652399, 652659]</code>, requisitando <code>4 * 4 * 8 = 128 bytes</code>.
Mas é possível ir além dado que a lista de ids é ordenada, assim é possível guardar apenas os <em>gaps</em> (saltos) entre os ids.
Seguindo o exemplo anterior, a lista a ser persistida seria <code>[652389, 1, 9, 260]</code> porque <code>[652389, 652390 = 652389 + 1, 652399 = 652390 + 9, 652659 = 652399 + 260]</code>.
Mesmo assim, asinda é necessário guardar 4 inteiros totalizando 128 bytes.
Mas agora, obervando bem os valores, é possível perceber que apenas <code>652389</code> e <code>260</code> requerem um tipo <code>int</code>, os valores <code>1</code> e <code>9</code> podem ser armazenados com apenas 1 byte cada um (1 byte pode armazenar valores de 0 à 255).
Assim, o espaço foi reduzido para <code>2 * 4 * 8 + 2 * 8 = 80 bytes</code> (um pouco mais da metade do espaço necessário anteriormente).</p><p>Uma das técnicas para fazer essa compressão de uma <em>postings list</em> com bytes é o <em>Variable Byte Encoding</em> (VBE).
A ideia é alocar a <em>postings list</em> como um <em>stream</em> (fluxo) de bytes, assim números que podem ser armazenados com apenas um byte são auto contidos, e números maiores requisitam mais bytes.
Isso é possível fazendo que o bit mais a esquerda indique se o byte atual é o último de uma sequência (bit = 1) ou se é necessário ler mais bytes para obter o número (bit = 0).
Os outros 7 bits são usados para guardar o valor desejado.
A tabela abaixo mostra o exemplo acima</p><table><thead><tr><th style=text-align:left><em>Postings list</em></th><th style=text-align:left>652389</th><th style=text-align:left>652390</th><th style=text-align:left>652399</th><th style=text-align:left>652659</th></tr></thead><tbody><tr><td style=text-align:left><em>gaps</em></td><td style=text-align:left>652389</td><td style=text-align:left>1</td><td style=text-align:left>9</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>VBE</td><td style=text-align:left>00100111 01101000 11100101</td><td style=text-align:left>10000001</td><td style=text-align:left>10001001</td><td style=text-align:left>00000010 10000100</td></tr></tbody></table><p>A partir da tabela acima é possível perceber que apenas 7 bytes são necessários para armazenar os devidos números.
Também é possível notar que o número <code>1</code>, se verificar o número gerado, é <code>129</code>, isso porque o bit mais a esquerda é o indicador de final da sequência, portanto, precisa ser verdadeiro.</p><p>As implementações abaixo para codificar uma <em>postings list</em> são baseadas nesse <a href=https://nlp.stanford.edu/IR-book/html/htmledition/variable-byte-codes-1.html class=external-link target=_blank rel=noopener>pseudo-código</a>.</p><p>O primeiro passo é codificar um número, que consiste em, basicamente, dividir um número por 128, enquanto ele é divisível por 128.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>def</span> encode_number(n):
</span></span><span style=display:flex><span>    b = bytearray()
</span></span><span style=display:flex><span>    <span style=font-weight:700>while</span> <span style=font-weight:700>True</span>:
</span></span><span style=display:flex><span>        b.insert(0, n % 128)
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> n &lt; 128:
</span></span><span style=display:flex><span>            <span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>        n = n // 128
</span></span><span style=display:flex><span>    b[len(b) - 1] |= 128  <span style=font-style:italic># informa que esse é o último byte da sequência</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> encode_number(652389) == bytearray([39, 104, 229])
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> encode_number(1) == bytearray([129])
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> encode_number(9) == bytearray([137])
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> encode_number(260) == bytearray([2, 132])
</span></span></code></pre></div><p>Agora é possível usar essa função para codificar uma sequência de números.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> encode(postings_list):
</span></span><span style=display:flex><span>    encoded = encode_number(postings_list[0])
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> (n1, n2) <span style=font-weight:700>in</span> zip(postings_list[:-1], postings_list[1:]):
</span></span><span style=display:flex><span>        e = encode_number(n2 - n1)
</span></span><span style=display:flex><span>        encoded += e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> bytes(encoded)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> encode([652389, 652390, 652399, 652659]) == bytes([39, 104, 229, 129, 137, 2, 132])
</span></span></code></pre></div><p>Note que essa função apenas calcula a diferença entre os ids e acumula uma sequência de bytes gerada por <code>encode_number</code>.
Uma vez que a <em>postings list</em> foi compactada, também é necessário descompactar para obter os ids originais.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>def</span> decode(encoded_postings_list):
</span></span><span style=display:flex><span>    decoded = [0]
</span></span><span style=display:flex><span>    n = 0
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> b <span style=font-weight:700>in</span> encoded_postings_list:
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> b &lt; 128:
</span></span><span style=display:flex><span>            n = 128 * n + b
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>            n = 128 * n + (b - 128)
</span></span><span style=display:flex><span>            decoded.append(n + decoded[-1])
</span></span><span style=display:flex><span>            n = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> decoded[1:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> decode(bytes([39, 104, 229, 129, 137, 2, 132])) == [652389, 652390, 652399, 652659]
</span></span></code></pre></div><p>A implementação acima começa a lista com <code>0</code>, para facilitar a decodificação que precisa somar com o valor anterior.
Assim, não é necessário ter uma tratativa para o primeiro valor (visto que não teria uma valor anterior).</p><p>Com essas três funções simples é possível compactar a representação em bytes de uma lista de números sequências.
A ideia é transformar a sequência de números em uma sequência de diferenças (<em>gaps</em>) e utilizar a menor quantidade de bytes para armazená-los.
O detalhe é o armazenamento de quantidades variadas de bytes para cada número com o uso de um bit de indicação (0 se precisa ler mais bytes, 1 se é o último byte do número atual).</p><p>Referências:</p><ul><li><a href=https://nlp.stanford.edu/IR-book/html/htmledition/variable-byte-codes-1.html class=external-link target=_blank rel=noopener>Variable byte codes</a></li><li><a href=https://www.systems.ethz.ch/sites/default/files/file/ir2018spring/06%20Information%20Retrieval%20-%20Index%20Compression.pdf class=external-link target=_blank rel=noopener>6. Index Compression</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2024
Júlio César Batista
·
Promovido por <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-1BE56W9H8M"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1BE56W9H8M")}</script></body></html>